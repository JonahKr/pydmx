from abc import ABC, abstractmethod
from enum import Enum
from platform import system
from threading import Thread
from time import sleep


class OS(Enum):
    LINUX = 1
    WINDOWS = 2


global operatingsystem
if system() == "Linux":
    operatingsystem = OS.LINUX
elif system() == "Windows":
    operatingsystem = OS.WINDOWS


class DMXController(ABC):
    """
    DMX Controller Base Class
    """

    """
  Source: DMX512 Protocol Implementation Using MC9S08GT60 8-Bit MCU By NXP
    https://web.archive.org/web/20170830235842/http://cache.freescale.com/files/microcontrollers/doc/app_note/AN3315.pdf
  
    2. DMX512 Protocol Overview:
      The DMX512 protocol is simple because it is an asynchronous 8-bit serial protocol and works in an
      unidirectional line generated by a master device (or console). The protocol can handle up to 512 devices
      in a DMX network and communicates at 250 kbps baud rate. Each bit in the frame is generated every 4us.
    
    2.2 Data Protocol:


  """

    @abstractmethod
    def __init__(self, *args, **kwargs):
        """Initialising the DMX Controller"""
        self._dmxdata: bytes = bytes((0,) * 512)
        self.active = False
        self._writer_delay = 0.3
        self.thread = Thread(target=self.writer_thread, daemon=True)

    @property
    def dmxdata(self):
        """"""
        return self._dmxdata

    @dmxdata.setter
    def dmxdata(self, value: bytes):
        self._dmxdata = value

    @abstractmethod
    def write(self):
        """Writing 512 Bytes of DMX Data"""
        raise NotImplementedError("Must override write Method!")

    def activate(self):
        self.active = True

    def deactivate(self):
        self.active = False

    def writer_thread(self):
        while True:
            if not self.active:
                continue
            self.write()
            # The Sleep intervall has to be a max 0.3
            sleep(self._writer_delay)
